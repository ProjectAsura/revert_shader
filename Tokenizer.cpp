//-------------------------------------------------------------------------------------------------
// File : Tokenizer.cpp
// Desc : Tokenizer Module.
// Copyright(c) Project Asura All right reserved.
//-------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------
// Includes
//-------------------------------------------------------------------------------------------------
#include "Tokenizer.h"
#include <new>


namespace {

//-------------------------------------------------------------------------------------------------
//      小文字にして部分文字列比較を行います.
//-------------------------------------------------------------------------------------------------
static const char *stristr (const char *haystack, const char *needle)
{
    int haypos;
    int needlepos;

    haypos = 0;
    while (haystack[haypos]) 
    {
        if (tolower (haystack[haypos]) == tolower(needle[0])) 
        {
            needlepos = 1;
            while ( (needle[needlepos]) &&
                    (tolower(haystack[haypos + needlepos])
                    == tolower(needle[needlepos])) )
                ++needlepos;
            if (!needle[needlepos])
                return (haystack + haypos);
        }
        ++haypos;
    }
    return NULL;
}

} // namespace

///////////////////////////////////////////////////////////////////////////////////////////////////
// Tokenizer class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      コンストラクタです.
//-------------------------------------------------------------------------------------------------
Tokenizer::Tokenizer()
: m_pBuffer     (nullptr)
, m_pPtr        (nullptr)
, m_pToken      (nullptr)
, m_Separator   ()
, m_CutOff      ()
, m_BufferSize  (0)
{ /* DO_NOTHING */ }

//-------------------------------------------------------------------------------------------------
//      デストラクタです.
//-------------------------------------------------------------------------------------------------
Tokenizer::~Tokenizer()
{ Term(); }

//-------------------------------------------------------------------------------------------------
//      初期化処理を行います.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::Init(uint32_t size)
{
    m_pToken = new(std::nothrow) char[size];
    if (m_pToken == nullptr)
    { return false; }

    memset(m_pToken, 0, sizeof(char) * size);
    m_BufferSize = size;

    return true;
}

//-------------------------------------------------------------------------------------------------
//      終了処理を行います.
//-------------------------------------------------------------------------------------------------
void Tokenizer::Term()
{
    if (m_pToken != nullptr)
    {
        delete [] m_pToken;
        m_pToken = nullptr;
    }

    m_Separator.clear();
    m_CutOff.clear();
    m_pPtr      = nullptr;
    m_pBuffer   = nullptr;
}

//-------------------------------------------------------------------------------------------------
//      区切り文字を設定します.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SetSeparator(const char *separator)
{ m_Separator = std::string(separator); }

//-------------------------------------------------------------------------------------------------
//      区切り文字を設定します.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SetSeparator(const std::string& separator)
{ m_Separator = separator; }

//-------------------------------------------------------------------------------------------------
//      切り出し文字を設定します.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SetCutOff(const char *cutoff)
{ m_CutOff = std::string(cutoff); }

//-------------------------------------------------------------------------------------------------
//      切り出し文字を設定します.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SetCutOff(const std::string& cutoff)
{ m_CutOff = cutoff; }

//-------------------------------------------------------------------------------------------------
//      バッファを設定します.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SetBuffer(char *buffer)
{
    m_pBuffer = buffer;
    m_pPtr    = buffer;

    Next();
}

//-------------------------------------------------------------------------------------------------
//      次のトークンを取得します.
//-------------------------------------------------------------------------------------------------
void Tokenizer::Next()
{
    auto p = m_pPtr;
    auto q = m_pToken;

    // 区切り文字はスキップする
    while ((*p) != '\0' && strchr(m_Separator.c_str(), *p))
    { p++; }

    // 切り出し文字とヒットするか判定
    if (strchr(m_CutOff.c_str(), *p))
    {
        //切り出し文字とヒットしたら，単体トークンとする
        if (size_t(q - m_pToken) < m_BufferSize)
        { (*(q++)) = (*(p++)); }
        else
        { p++; }
    }
    else
    {
        //区切り文字または切り出し文字以外ならトークンとする
        std::string split = m_Separator + m_CutOff;
        while (*p != '\0' && !strchr(split.c_str(), *p))
        {
            if (size_t(q - m_pToken) < m_BufferSize)
            { (*(q++)) = (*(p++)); }
            else
            { p++; }
        }
    }

    //抜き出した分だけバッファを進める
    m_pPtr = p;

    //文字列として返すためにNULL終端文字を加える
    *q = '\0';
}

//-------------------------------------------------------------------------------------------------
//      指定した文字列が出てくるまでトークンを読み飛ばします.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SkipTo(const char* text)
{
    while(!IsEnd())
    {
        if (Contain(text))
        { break; }

        Next();
    }
}

//-------------------------------------------------------------------------------------------------
//      指定した文字列が出てくるまでトークンを読み飛ばします.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SkipTo(const std::string& text)
{ SkipTo(text.c_str()); }

//-------------------------------------------------------------------------------------------------
//      改行コードが出てくるまで読み飛ばします.
//-------------------------------------------------------------------------------------------------
void Tokenizer::SkipLine()
{
    auto p = m_pPtr;
    auto q = m_pToken;

    // 区切り文字はスキップする
    while ((*p) != '\0' && strchr(" \t", *p))
    { p++; }

    auto pos = strstr(p, "\n");
    if (pos != nullptr)
    {
        m_pPtr = pos;
        m_pToken[0] = '\0';
    }
}

//-------------------------------------------------------------------------------------------------
//      トークンを1行として取得します.
//-------------------------------------------------------------------------------------------------
char* Tokenizer::GetLine()
{
    auto p = m_pPtr;
    auto q = m_pToken;

    // 区切り文字はスキップする
    while ((*p) != '\0' && strchr(" \t", *p))
    { p++; }

    auto pos = strstr(p, "\n");
    if (pos != nullptr)
    {
        auto size = pos - p;
        memcpy(m_pToken, p, size);
        m_pToken[size] = '\n';
        m_pToken[size + 1] = '\0';
        p += size;
    }

    m_pPtr = p;

    return m_pToken;
}

//-------------------------------------------------------------------------------------------------
//      指定された文字列とトークンが一致するかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::Compare(const char *token) const
{ return (strcmp(m_pToken, token) == 0); }

//-------------------------------------------------------------------------------------------------
//      指定された文字列とトークンが一致するかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::Compare(const std::string& token) const
{ return (strcmp(m_pToken, token.c_str() ) == 0); }

//-------------------------------------------------------------------------------------------------
//      指定された文字列とトークンが一致するかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::CompareAsLower(const char *token) const
{ return (_stricmp(m_pToken, token) == 0); }

//-------------------------------------------------------------------------------------------------
//      指定された文字列とトークンが一致するかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::CompareAsLower(const std::string& token) const
{ return CompareAsLower(token.c_str()); }

//-------------------------------------------------------------------------------------------------
//      指定された文字列を含むかどうかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::Contain(const char* token) const
{ return strstr(m_pToken, token) != nullptr; }

//-------------------------------------------------------------------------------------------------
//      指定された文字列を含むかどうかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::Contain(const std::string& token) const
{ return Contain(token.c_str()); }

//-------------------------------------------------------------------------------------------------
//      指定された文字列を含むかどうかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::ContainAsLower(const char* token) const
{ return stristr(m_pToken, token) != nullptr; }

//-------------------------------------------------------------------------------------------------
//      指定された文字列を含むかどうかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::ContainAsLower(const std::string& token) const
{ return ContainAsLower(token.c_str()); }

//-------------------------------------------------------------------------------------------------
//      最後かどうかチェックします.
//-------------------------------------------------------------------------------------------------
bool Tokenizer::IsEnd() const
{ return (*m_pPtr == '\0' || m_pPtr == nullptr); }

//-------------------------------------------------------------------------------------------------
//      バッファを取得します.
//-------------------------------------------------------------------------------------------------
char* Tokenizer::GetBuffer() const
{ return m_pBuffer; }

//-------------------------------------------------------------------------------------------------
//      現在のポインタを取得します.
//-------------------------------------------------------------------------------------------------
char* Tokenizer::GetPtr() const
{ return m_pPtr; }

//-------------------------------------------------------------------------------------------------
//      char型としてトークンを取得します.
//-------------------------------------------------------------------------------------------------
char* Tokenizer::GetAsChar() const
{ return m_pToken; }

//-------------------------------------------------------------------------------------------------
//      double型としてトークンを取得します.
//-------------------------------------------------------------------------------------------------
double Tokenizer::GetAsDouble() const
{ return atof(m_pToken); }

//-------------------------------------------------------------------------------------------------
//      float型としてトークンを取得します.
//-------------------------------------------------------------------------------------------------
float Tokenizer::GetAsFloat() const
{ return static_cast<float>(atof(m_pToken)); }

//-------------------------------------------------------------------------------------------------
//      int型としてトークンを取得します.
//-------------------------------------------------------------------------------------------------
int Tokenizer::GetAsInt() const
{ return atoi(m_pToken); }

//-------------------------------------------------------------------------------------------------
//      std::string型としてトークンを取得します.
//-------------------------------------------------------------------------------------------------
std::string Tokenizer::GetAsString() const
{ return std::string(m_pToken); }

//-------------------------------------------------------------------------------------------------
//      次のトークンを取得して，char型として返却します.
//-------------------------------------------------------------------------------------------------
char* Tokenizer::NextAsChar()
{
    Next();
    return GetAsChar();
}

//-------------------------------------------------------------------------------------------------
//      次のトークンを取得して，double型として返却します.
//-------------------------------------------------------------------------------------------------
double Tokenizer::NextAsDouble()
{
    Next();
    return GetAsDouble();
}

//-------------------------------------------------------------------------------------------------
//      次のトークンを取得して，float型として返却します.
//-------------------------------------------------------------------------------------------------
float Tokenizer::NextAsFloat()
{
    Next();
    return GetAsFloat();
}

//-------------------------------------------------------------------------------------------------
//      次のトークンを取得して，int型として返却します.
//-------------------------------------------------------------------------------------------------
int Tokenizer::NextAsInt()
{
    Next();
    return GetAsInt();
}

//-------------------------------------------------------------------------------------------------
//      次のトークンを取得して，std::string型として返却します.
//-------------------------------------------------------------------------------------------------
std::string Tokenizer::NextAsString()
{
    Next();
    return GetAsString();
}

